name: Splunk Upgrade

on:
  workflow_dispatch:
    inputs:
      target_mode:
        description: 'Upgrade mode'
        required: true
        type: choice
        options:
          - all_servers_in_class
          - single_server
        default: 'single_server'
      host_class:
        description: 'Select host class (required for both modes)'
        required: true
        type: choice
        options:
          - azure_hf
          - azure_uf
      server_name:
        description: 'Server name (only for single_server mode: azure_hf_1, azure_hf_2, azure_uf_1, azure_uf_2)'
        required: false
        type: string
      package_id:
        description: 'Select package to install'
        required: true
        type: choice
        options:
          - splunk_enterprise_9.3.2
          - splunk_enterprise_9.3.1
          - splunk_enterprise_9.3.0
          - splunk_enterprise_9.2.11
          - splunk_enterprise_9.2.10
          - splunk_enterprise_9.2.9
          - splunk_enterprise_9.2.8
          - splunk_uf_9.4.5
          - splunk_uf_9.4.6

jobs:
  prepare:
    name: Prepare Upgrade Configuration
    runs-on: ubuntu-latest
    outputs:
      servers: ${{ steps.parse.outputs.servers }}
      package_url: ${{ steps.parse.outputs.package_url }}
      package_version: ${{ steps.parse.outputs.package_version }}
      package_type: ${{ steps.parse.outputs.package_type }}
      install_path: ${{ steps.parse.outputs.install_path }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Parse inventory files
        id: parse
        run: |
          # Install jq for JSON parsing
          sudo apt-get update && sudo apt-get install -y jq
          
          # Parse host inventory based on mode
          if [ "${{ github.event.inputs.target_mode }}" == "single_server" ]; then
            # Single server mode - filter by server name
            SERVERS=$(jq -c '.classes[] | select(.name == "${{ github.event.inputs.host_class }}") | .servers[] | select(.name == "${{ github.event.inputs.server_name }}") | [.]' inventory/host.json)
            
            if [ "$SERVERS" == "[]" ] || [ -z "$SERVERS" ]; then
              echo "âŒ Error: Server '${{ github.event.inputs.server_name }}' not found in class '${{ github.event.inputs.host_class }}'"
              exit 1
            fi
            
            echo "ğŸ¯ Single Server Mode: ${{ github.event.inputs.server_name }}"
          else
            # All servers in class mode
            SERVERS=$(jq -c '.classes[] | select(.name == "${{ github.event.inputs.host_class }}") | .servers' inventory/host.json)
            
            SERVER_COUNT=$(echo "$SERVERS" | jq '. | length')
            echo "ğŸŒ All Servers Mode: Upgrading $SERVER_COUNT servers in class '${{ github.event.inputs.host_class }}'"
          fi
          
          echo "servers=$SERVERS" >> $GITHUB_OUTPUT
          
          # Parse package inventory
          PACKAGE_URL=$(jq -r '.packages[] | select(.id == "${{ github.event.inputs.package_id }}") | .download_url' inventory/package.json)
          PACKAGE_VERSION=$(jq -r '.packages[] | select(.id == "${{ github.event.inputs.package_id }}") | .version' inventory/package.json)
          PACKAGE_TYPE=$(jq -r '.packages[] | select(.id == "${{ github.event.inputs.package_id }}") | .type' inventory/package.json)
          INSTALL_PATH=$(jq -r '.packages[] | select(.id == "${{ github.event.inputs.package_id }}") | .install_path' inventory/package.json)
          
          echo "package_url=$PACKAGE_URL" >> $GITHUB_OUTPUT
          echo "package_version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          echo "package_type=$PACKAGE_TYPE" >> $GITHUB_OUTPUT
          echo "install_path=$INSTALL_PATH" >> $GITHUB_OUTPUT
          
          echo "ğŸ“¦ Selected Package: ${{ github.event.inputs.package_id }}"
          echo "ğŸ”— Download URL: $PACKAGE_URL"
          echo "ğŸ“Œ Version: $PACKAGE_VERSION"
          echo "ğŸ–¥ï¸  Host Class: ${{ github.event.inputs.host_class }}"

  upgrade:
    name: Upgrade Server
    needs: prepare
    runs-on: ubuntu-latest
    strategy:
      matrix:
        server: ${{ fromJson(needs.prepare.outputs.servers) }}
      max-parallel: 1  # Upgrade one server at a time
      fail-fast: false  # Continue even if one server fails
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Splunk Installer
        run: |
          mkdir -p ${{ runner.temp }}/installer
          echo "ğŸ“¥ Downloading package from: ${{ needs.prepare.outputs.package_url }}"
          wget -O ${{ runner.temp }}/installer/splunk-installer.tgz "${{ needs.prepare.outputs.package_url }}"
          ls -lh ${{ runner.temp }}/installer/

      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ matrix.server.ip }} >> ~/.ssh/known_hosts

      - name: Display Server Info
        run: |
          echo "ğŸ–¥ï¸  Upgrading Server: ${{ matrix.server.name }}"
          echo "ğŸ“ IP Address: ${{ matrix.server.ip }}"
          echo "ğŸ­ Role: ${{ matrix.server.role }}"
          echo "ğŸ§ OS: ${{ matrix.server.os }}"
          echo "ğŸ“¦ Package Version: ${{ needs.prepare.outputs.package_version }}"

      - name: Copy Upgrade Script to Target Server
        run: |
          scp -i ~/.ssh/id_rsa upgrade_splunk.sh ${{ secrets.SSH_USER }}@${{ matrix.server.ip }}:/tmp/upgrade_splunk.sh
          ssh -i ~/.ssh/id_rsa ${{ secrets.SSH_USER }}@${{ matrix.server.ip }} "chmod +x /tmp/upgrade_splunk.sh"

      - name: Copy Installer to Target Server
        run: |
          echo "ğŸ“¤ Copying installer to ${{ matrix.server.name }}..."
          scp -i ~/.ssh/id_rsa ${{ runner.temp }}/installer/splunk-installer.tgz ${{ secrets.SSH_USER }}@${{ matrix.server.ip }}:/opt/splunk_installer.tgz

      - name: Execute Upgrade on Target Server
        run: |
          echo "ğŸš€ Starting upgrade on ${{ matrix.server.name }}..."
          ssh -i ~/.ssh/id_rsa ${{ secrets.SSH_USER }}@${{ matrix.server.ip }} << 'EOF'
            sudo SPLUNK_VERSION="${{ needs.prepare.outputs.package_version }}" \
                 SPLUNK_INSTALLER_PATH="/opt/splunk_installer.tgz" \
                 SPLUNK_HOME="${{ needs.prepare.outputs.install_path }}" \
                 /tmp/upgrade_splunk.sh
          EOF

      - name: Verify Upgrade
        run: |
          echo "âœ… Verifying upgrade on ${{ matrix.server.name }}..."
          ssh -i ~/.ssh/id_rsa ${{ secrets.SSH_USER }}@${{ matrix.server.ip }} << 'EOF'
            sudo ${{ needs.prepare.outputs.install_path }}/bin/splunk status
            VERSION=$(sudo ${{ needs.prepare.outputs.install_path }}/bin/splunk version)
            echo "âœ… Upgrade successful on ${{ matrix.server.name }}!"
            echo "ğŸ“Œ Version: $VERSION"
          EOF

      - name: Cleanup Target Server
        if: always()
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.SSH_USER }}@${{ matrix.server.ip }} \
            "rm -f /tmp/upgrade_splunk.sh /opt/splunk_installer.tgz" || true

      - name: Cleanup SSH Key
        if: always()
        run: |
          rm -f ~/.ssh/id_rsa

  summary:
    name: Upgrade Summary
    needs: [prepare, upgrade]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Display Summary
        run: |
          echo "================================================"
          echo "ğŸ‰ Splunk Upgrade Workflow Complete"
          echo "================================================"
          echo "ğŸ¯ Mode: ${{ github.event.inputs.target_mode }}"
          if [ "${{ github.event.inputs.target_mode }}" == "single_server" ]; then
            echo "ï¿½ï¸  Server: ${{ github.event.inputs.server_name }}"
          else
            echo "ğŸ–¥ï¸  Host Class: ${{ github.event.inputs.host_class }} (all servers)"
          fi
          echo "ğŸ“¦ Package: ${{ github.event.inputs.package_id }}"
          echo "ğŸ“Œ Version: ${{ needs.prepare.outputs.package_version }}"
          echo "================================================"

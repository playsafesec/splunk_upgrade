name: Splunk Upgrade

# Workflow permissions to allow committing logs
permissions:
  contents: write

on:
  workflow_dispatch:
    inputs:
      target_mode:
        description: 'Upgrade mode'
        required: true
        type: choice
        options:
          - all_servers_in_class
          - single_server
        default: 'single_server'
      host_class:
        description: 'Select host class (required for both modes)'
        required: true
        type: choice
        options:
          - azure_hf
          - azure_uf
      server_name:
        description: 'Server name (only for single_server mode: azure_hf_1, azure_hf_2, azure_uf_1, azure_uf_2)'
        required: false
        type: string
      package_id:
        description: 'Select package to install'
        required: true
        type: choice
        options:
          - splunk_enterprise_9.3.3
          - splunk_enterprise_9.3.2
          - splunk_enterprise_9.3.1
          - splunk_enterprise_9.3.0
          - splunk_enterprise_9.2.11
          - splunk_enterprise_9.2.10
          - splunk_enterprise_9.2.9
          - splunk_enterprise_9.2.8
          - splunk_enterprise_9.2.7
          - splunk_uf_9.4.5
          - splunk_uf_9.4.6
          - splunk_uf_9.4.7

jobs:
  init_logging:
    name: Initialize Workflow Logging
    runs-on: ubuntu-latest
    outputs:
      run_id: ${{ steps.init_log.outputs.run_id }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Initialize Log File
        id: init_log
        run: |
          # Install jq for JSON manipulation
          sudo apt-get update && sudo apt-get install -y jq
          
          # Generate unique run ID
          RUN_ID="run_$(date -u +%Y%m%d_%H%M%S)"
          echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
          
          # Source logging helper
          source scripts/log_helper.sh
          
          # Create inputs JSON
          INPUTS_JSON=$(jq -n \
            --arg mode "${{ github.event.inputs.target_mode }}" \
            --arg class "${{ github.event.inputs.host_class }}" \
            --arg server "${{ github.event.inputs.server_name }}" \
            --arg package "${{ github.event.inputs.package_id }}" \
            '{
              target_mode: $mode,
              host_class: $class,
              server_name: $server,
              package_id: $package
            }')
          
          # Initialize log file
          init_log "$RUN_ID" "Splunk Upgrade" "$INPUTS_JSON"
          
          echo "âœ… Logging initialized with Run ID: $RUN_ID"

      - name: Upload Log Artifact
        uses: actions/upload-artifact@v4
        with:
          name: workflow-logs
          path: logs/

  prepare:
    name: Prepare Upgrade Configuration
    needs: init_logging
    runs-on: ubuntu-latest
    outputs:
      servers: ${{ steps.parse.outputs.servers }}
      package_url: ${{ steps.parse.outputs.package_url }}
      package_version: ${{ steps.parse.outputs.package_version }}
      package_type: ${{ steps.parse.outputs.package_type }}
      install_path: ${{ steps.parse.outputs.install_path }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Log Artifact
        uses: actions/download-artifact@v4
        with:
          name: workflow-logs
          path: logs/

      - name: Update Job Status - Started
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          source scripts/log_helper.sh
          update_job_status "${{ needs.init_logging.outputs.run_id }}" "prepare" "running"

      - name: Parse inventory files
        id: parse
        run: |
          # Install jq for JSON parsing (already installed above)
          source scripts/log_helper.sh
          
          # Parse host inventory based on mode
          if [ "${{ github.event.inputs.target_mode }}" == "single_server" ]; then
            # Single server mode - filter by server name
            SERVERS=$(jq -c '.classes[] | select(.name == "${{ github.event.inputs.host_class }}") | .servers[] | select(.name == "${{ github.event.inputs.server_name }}") | [.]' inventory/host.json)
            
            if [ "$SERVERS" == "[]" ] || [ -z "$SERVERS" ]; then
              echo "âŒ Error: Server '${{ github.event.inputs.server_name }}' not found in class '${{ github.event.inputs.host_class }}'"
              exit 1
            fi
            
            echo "ğŸ¯ Single Server Mode: ${{ github.event.inputs.server_name }}"
          else
            # All servers in class mode
            SERVERS=$(jq -c '.classes[] | select(.name == "${{ github.event.inputs.host_class }}") | .servers' inventory/host.json)
            
            SERVER_COUNT=$(echo "$SERVERS" | jq '. | length')
            echo "ğŸŒ All Servers Mode: Upgrading $SERVER_COUNT servers in class '${{ github.event.inputs.host_class }}'"
          fi
          
          echo "servers=$SERVERS" >> $GITHUB_OUTPUT
          
          # Parse package inventory
          PACKAGE_URL=$(jq -r '.packages[] | select(.id == "${{ github.event.inputs.package_id }}") | .download_url' inventory/package.json)
          PACKAGE_VERSION=$(jq -r '.packages[] | select(.id == "${{ github.event.inputs.package_id }}") | .version' inventory/package.json)
          PACKAGE_TYPE=$(jq -r '.packages[] | select(.id == "${{ github.event.inputs.package_id }}") | .type' inventory/package.json)
          INSTALL_PATH=$(jq -r '.packages[] | select(.id == "${{ github.event.inputs.package_id }}") | .install_path' inventory/package.json)
          
          echo "package_url=$PACKAGE_URL" >> $GITHUB_OUTPUT
          echo "package_version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          echo "package_type=$PACKAGE_TYPE" >> $GITHUB_OUTPUT
          echo "install_path=$INSTALL_PATH" >> $GITHUB_OUTPUT
          
          echo "ğŸ“¦ Selected Package: ${{ github.event.inputs.package_id }}"
          echo "ğŸ”— Download URL: $PACKAGE_URL"
          echo "ğŸ“Œ Version: $PACKAGE_VERSION"
          echo "ğŸ–¥ï¸  Host Class: ${{ github.event.inputs.host_class }}"

      - name: Update Job Status - Completed
        if: success()
        run: |
          source scripts/log_helper.sh
          
          # Create outputs JSON
          OUTPUTS_JSON=$(jq -n \
            --arg servers '${{ steps.parse.outputs.servers }}' \
            --arg url "${{ steps.parse.outputs.package_url }}" \
            --arg version "${{ steps.parse.outputs.package_version }}" \
            --arg type "${{ steps.parse.outputs.package_type }}" \
            --arg path "${{ steps.parse.outputs.install_path }}" \
            '{
              servers: $servers,
              package_url: $url,
              package_version: $version,
              package_type: $type,
              install_path: $path
            }')
          
          update_job_status "${{ needs.init_logging.outputs.run_id }}" "prepare" "success" "$OUTPUTS_JSON"

      - name: Update Job Status - Failed
        if: failure()
        run: |
          source scripts/log_helper.sh
          update_job_status "${{ needs.init_logging.outputs.run_id }}" "prepare" "failure"
          add_error "${{ needs.init_logging.outputs.run_id }}" "Prepare job failed" "Failed during inventory parsing"

      - name: Upload Log Artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: workflow-logs
          path: logs/
          overwrite: true

  upgrade:
    name: Upgrade Server
    needs: [init_logging, prepare]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        server: ${{ fromJson(needs.prepare.outputs.servers) }}
      max-parallel: 1  # Upgrade one server at a time
      fail-fast: false  # Continue even if one server fails
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Log Artifact
        uses: actions/download-artifact@v4
        with:
          name: workflow-logs
          path: logs/

      - name: Setup Logging
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          source scripts/log_helper.sh
          update_server_status "${{ needs.init_logging.outputs.run_id }}" \
            "${{ matrix.server.name }}" \
            "${{ matrix.server.ip }}" \
            "running" \
            "Server upgrade started" \
            "Initializing upgrade for ${{ matrix.server.name }}"

      - name: Download Splunk Installer
        run: |
          mkdir -p ${{ runner.temp }}/installer
          echo "ğŸ“¥ Downloading package from: ${{ needs.prepare.outputs.package_url }}"
          wget -O ${{ runner.temp }}/installer/splunk-installer.tgz "${{ needs.prepare.outputs.package_url }}"
          ls -lh ${{ runner.temp }}/installer/

      - name: Log Download Complete
        run: |
          source scripts/log_helper.sh
          update_server_status "${{ needs.init_logging.outputs.run_id }}" \
            "${{ matrix.server.name }}" \
            "${{ matrix.server.ip }}" \
            "running" \
            "Downloaded Splunk installer" \
            "Package downloaded successfully"

      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ matrix.server.ip }} >> ~/.ssh/known_hosts

      - name: Log SSH Setup Complete
        run: |
          source scripts/log_helper.sh
          update_server_status "${{ needs.init_logging.outputs.run_id }}" \
            "${{ matrix.server.name }}" \
            "${{ matrix.server.ip }}" \
            "running" \
            "SSH connection established" \
            "SSH key configured and connection ready"

      - name: Display Server Info
        run: |
          echo "ğŸ–¥ï¸  Upgrading Server: ${{ matrix.server.name }}"
          echo "ğŸ“ IP Address: ${{ matrix.server.ip }}"
          echo "ğŸ­ Role: ${{ matrix.server.role }}"
          echo "ğŸ§ OS: ${{ matrix.server.os }}"
          echo "ğŸ“¦ Package Version: ${{ needs.prepare.outputs.package_version }}"

      - name: Copy Upgrade Script to Target Server
        run: |
          scp -i ~/.ssh/id_rsa upgrade_splunk.sh ${{ secrets.SSH_USER }}@${{ matrix.server.ip }}:/tmp/upgrade_splunk.sh
          ssh -i ~/.ssh/id_rsa ${{ secrets.SSH_USER }}@${{ matrix.server.ip }} "chmod +x /tmp/upgrade_splunk.sh"

      - name: Copy Installer to Target Server
        run: |
          echo "ğŸ“¤ Copying installer to ${{ matrix.server.name }}..."
          scp -i ~/.ssh/id_rsa ${{ runner.temp }}/installer/splunk-installer.tgz ${{ secrets.SSH_USER }}@${{ matrix.server.ip }}:/opt/splunk_installer.tgz

      - name: Log Installer Copied
        run: |
          source scripts/log_helper.sh
          update_server_status "${{ needs.init_logging.outputs.run_id }}" \
            "${{ matrix.server.name }}" \
            "${{ matrix.server.ip }}" \
            "running" \
            "Installer copied to server" \
            "Package transferred to target server"

      - name: Execute Upgrade on Target Server
        id: execute_upgrade
        run: |
          echo "ğŸš€ Starting upgrade on ${{ matrix.server.name }}..."
          ssh -i ~/.ssh/id_rsa ${{ secrets.SSH_USER }}@${{ matrix.server.ip }} <<'EOF'
            sudo SPLUNK_VERSION="${{ needs.prepare.outputs.package_version }}" \
                 SPLUNK_INSTALLER_PATH="/opt/splunk_installer.tgz" \
                 SPLUNK_HOME="${{ needs.prepare.outputs.install_path }}" \
                 /tmp/upgrade_splunk.sh
          EOF

      - name: Log Upgrade Executed
        run: |
          source scripts/log_helper.sh
          update_server_status "${{ needs.init_logging.outputs.run_id }}" \
            "${{ matrix.server.name }}" \
            "${{ matrix.server.ip }}" \
            "running" \
            "Upgrade script executed" \
            "Splunk upgrade completed on target server"

      - name: Verify Upgrade
        id: verify
        run: |
          echo "âœ… Verifying upgrade on ${{ matrix.server.name }}..."
          VERIFY_OUTPUT=$(ssh -i ~/.ssh/id_rsa ${{ secrets.SSH_USER }}@${{ matrix.server.ip }} <<'EOF'
            sudo ${{ needs.prepare.outputs.install_path }}/bin/splunk status
            VERSION=$(sudo ${{ needs.prepare.outputs.install_path }}/bin/splunk version)
            echo "âœ… Upgrade successful on ${{ matrix.server.name }}!"
            echo "ğŸ“Œ Version: $VERSION"
            echo "$VERSION"
          EOF
          )
          echo "$VERIFY_OUTPUT"
          echo "verify_output<<EOF" >> $GITHUB_OUTPUT
          echo "$VERIFY_OUTPUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Log Verification Success
        if: success()
        run: |
          source scripts/log_helper.sh
          update_server_status "${{ needs.init_logging.outputs.run_id }}" \
            "${{ matrix.server.name }}" \
            "${{ matrix.server.ip }}" \
            "success" \
            "Upgrade verified" \
            "${{ steps.verify.outputs.verify_output }}"

      - name: Log Verification Failure
        if: failure()
        run: |
          source scripts/log_helper.sh
          update_server_status "${{ needs.init_logging.outputs.run_id }}" \
            "${{ matrix.server.name }}" \
            "${{ matrix.server.ip }}" \
            "failure" \
            "Upgrade failed" \
            "Verification failed or upgrade encountered errors"
          add_error "${{ needs.init_logging.outputs.run_id }}" \
            "Server upgrade failed: ${{ matrix.server.name }}" \
            "Upgrade or verification step failed"

      - name: Cleanup Target Server
        if: always()
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.SSH_USER }}@${{ matrix.server.ip }} \
            "rm -f /tmp/upgrade_splunk.sh /opt/splunk_installer.tgz" || true

      - name: Cleanup SSH Key
        if: always()
        run: |
          rm -f ~/.ssh/id_rsa

      - name: Upload Log Artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: workflow-logs
          path: logs/
          overwrite: true

  summary:
    name: Upgrade Summary
    needs: [init_logging, prepare, upgrade]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Log Artifact
        uses: actions/download-artifact@v4
        with:
          name: workflow-logs
          path: logs/

      - name: Finalize Workflow Log
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          source scripts/log_helper.sh
          
          # Determine final status
          FINAL_STATUS="success"
          if [ "${{ needs.upgrade.result }}" == "failure" ]; then
            FINAL_STATUS="failure"
          elif [ "${{ needs.prepare.result }}" == "failure" ]; then
            FINAL_STATUS="failure"
          fi
          
          # Finalize the log
          finalize_log "${{ needs.init_logging.outputs.run_id }}" "$FINAL_STATUS"

      - name: Display Summary
        run: |
          echo "================================================"
          echo "ğŸ‰ Splunk Upgrade Workflow Complete"
          echo "================================================"
          echo "ï¿½ Run ID: ${{ needs.init_logging.outputs.run_id }}"
          echo "ï¿½ğŸ¯ Mode: ${{ github.event.inputs.target_mode }}"
          if [ "${{ github.event.inputs.target_mode }}" == "single_server" ]; then
            echo "ğŸ–¥ï¸  Server: ${{ github.event.inputs.server_name }}"
          else
            echo "ğŸ–¥ï¸  Host Class: ${{ github.event.inputs.host_class }} (all servers)"
          fi
          echo "ğŸ“¦ Package: ${{ github.event.inputs.package_id }}"
          echo "ğŸ“Œ Version: ${{ needs.prepare.outputs.package_version }}"
          echo "================================================"
          
          # Display log file info
          LOG_FILE="logs/${{ needs.init_logging.outputs.run_id }}.json"
          if [ -f "$LOG_FILE" ]; then
            echo ""
            echo "ğŸ“Š Workflow Summary:"
            jq -r '.summary | "Total Servers: \(.total_servers)\nSuccessful: \(.successful)\nFailed: \(.failed)\nDuration: \(.duration_seconds)s"' "$LOG_FILE"
            echo ""
            echo "ğŸ“ Log saved to: $LOG_FILE"
          fi

      - name: Commit and Push Logs
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # Check if there are changes to commit
          git add logs/
          
          if git diff --staged --quiet; then
            echo "ğŸ“­ No new logs to commit"
          else
            echo "ğŸ“ Committing new log files..."
            git commit -m "ğŸ“Š Add workflow run logs: ${{ needs.init_logging.outputs.run_id }}"
            
            echo "ğŸš€ Pushing logs to repository..."
            git push https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git HEAD:main
            
            echo "âœ… Logs successfully committed and pushed!"
          fi

